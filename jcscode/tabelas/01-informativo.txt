Base URL: https://api.jcscode.com/v1/auth

Database: jcscode

Schemas: auth, extensions

Stack:

Backend: NestJS v10+, TypeScript

DB: PostgreSQL 15+

ORM: TypeORM or Prisma (choose one per project; instructions below support both)

Auth: JWT access/refresh, bcrypt for password

Email: Nodemailer + Handlebars (Hostinger SMTP)

Docs: Swagger/OpenAPI

Tests: Jest + Supertest (E2E + unit)

Security: Passport-JWT, Helmet, Throttler (rate limit), CSRF for web-facing flows as needed

Database alignment and constraints
Extensions schema: Use schema “extensions” for uuid-ossp, pgcrypto, citext, pg_trgm, etc. Configure search_path to "$user", extensions.

Core tables in schema auth:

Users: auth.users (full identity, status, MFA fields)

Roles/RBAC: auth.roles, auth.user_roles

OAuth: auth.oauth_providers

Sessions: auth.sessions (refresh tokens, device info)

Verification tokens: auth.verification_tokens (email verification, password reset, magic link, etc.)

Audit trails: auth.login_history, auth.user_security_logs

Consent and maintenance: auth.consent_logs, auth.maintenance_logs

Optional: system admins and unified tokens (auth.system_users, auth.tokens, auth.system_audit_logs) if you enable platform-level administration.

Functions and triggers (auth):

auth.generate_secure_token(p_length)

auth.create_verification_token(...)

auth.validate_token(p_token, p_token_type)

auth.create_session(...)

auth.update_updated_at_column() trigger

auth.audit_user_changes() trigger

auth.cleanup_old_data()

IDs: UUID v4 generated by database via uuid_generate_v4(); do not generate IDs in the application layer (keep DB as source of truth).

Email module requirements
SMTP (Hostinger):

Host: smtp.hostinger.com

Port: 465 (SSL)

User: no-reply@jcscode.com

Pass: 143300Ju=

From: "JCS Code Auth" <no-reply@jcscode.com>

Email templates:

Account verification: 6-digit numeric code (rendered with branding and expiry).

Password recovery: UUID token embedded in link.

Suspicious login warning: Device/IP/location summary.

Reliability:

Error handling: Try/catch, do not fail API on SMTP errors. Log with structured metadata.

Queue-friendly: Abstract mailer calls for later queuing; provide an async interface.

Security and compliance
Passwords: bcrypt salt 10–12; enforce strong policy (length, complexity).

JWT: Short-lived access (e.g., 15m), refresh (e.g., 7d). Store only refresh hash in DB.

Rate limiting: 5 attempts/min on public auth routes; stricter for resend verification/reset passwords.

Audit: Every login attempt (success/failure) must write to auth.login_history.

MFA: TOTP support (enable/disable/verify, backup codes).

Consent logs: Record legal acceptances with version and context.

PII: Avoid returning sensitive fields in responses; filter DTOs carefully.

IP/device context: Capture ip_address, user_agent, device fingerprint where relevant.

Soft deletion: Use deleted_at for user accounts; retain audit trails.

Endpoint inventory
Below is an expanded set of 80 endpoints organized by module/tag. Each item includes method, path, and concise purpose. Use these to drive OpenAPI tags and NestJS modules. You can include or exclude platform admin features depending on your scope.

Auth (public) — registration, login, verification, recovery
POST /auth/signup: Create user, generate 6-digit code, send email.

POST /auth/signin: Verify password, issue JWT access + refresh, create DB session.

POST /auth/refresh: Exchange refresh for new access; rotate refresh optionally.

POST /auth/verify-email: Validate numeric code and activate account.

POST /auth/verify-email/resend: Issue a new verification code.

GET /auth/check-availability: Check if email or username is available.

POST /auth/forgot-password: Issue UUID reset token, send mail.

POST /auth/reset-password: Submit token + new password; mark token used.

POST /auth/magic-link: Generate magic-link token; send mail.

POST /auth/magic-link/verify: Exchange magic-link token for session.

POST /auth/token/introspect: Validate access token signature/claims (debug/admin).

POST /auth/token/revoke: Revoke a refresh token (if stored separately).

Users (self-service “me”) — profile and personal security
GET /users/me: Current user profile, roles, permissions summary.

PATCH /users/me: Update avatar/full_name/phone/timezone/language/metadata.

PATCH /users/me/password: Change password, requires current password.

POST /users/me/email: Request email change (send verification code to new email).

DELETE /users/me: Soft delete current account.

POST /users/me/consent: Register acceptance of legal terms with version.

GET /users/me/security-logs: List user’s security events.

GET /users/me/login-history: List user’s login attempts.

GET /users/me/sessions: List active sessions for user (devices list).

POST /users/me/signout: Invalidate current session (logout).

POST /users/me/signout-all: Invalidate all sessions of the user.

PUT /users/me/username: Change/claim username (unique check).

PUT /users/me/phone: Update phone (with verification flow if enabled).

MFA (two-factor)
POST /auth/mfa/setup: Provide TOTP secret/QR for enrollment.

POST /auth/mfa/enable: Confirm TOTP and enable MFA.

DELETE /auth/mfa/disable: Disable MFA (require password).

POST /auth/mfa/verify: Verify TOTP/backup code during login.

GET /auth/mfa/backup-codes: Retrieve backup codes (require password).

POST /auth/mfa/backup-codes: Regenerate backup codes.

Sessions (devices)
GET /sessions: List sessions for the current user.

DELETE /sessions/:id: Revoke a specific session.

DELETE /sessions: Revoke all sessions except current.

POST /sessions/:id/refresh: Manual refresh (optional; typically via /auth/refresh).

GET /sessions/:id: Inspect a single session record (self).

OAuth (social login)
GET /auth/oauth/google: Start Google OAuth.

GET /auth/oauth/google/callback: Handle Google callback, create/login user.

GET /auth/oauth/github: Start GitHub OAuth.

GET /auth/oauth/github/callback: Handle GitHub callback.

GET /auth/oauth/connections: List linked providers for current user.

DELETE /auth/oauth/connections/:provider: Unlink a provider.

POST /auth/oauth/login: Token-based OAuth login (mobile/native exchange).

Admin users (RBAC: admin role required)
GET /admin/users: Paginated list with filters (status, created_at, search).

POST /admin/users: Manually create a user (set initial status/roles).

GET /admin/users/:id: View sensitive/user details.

PATCH /admin/users/:id: Edit fields (status, verified flags, metadata).

DELETE /admin/users/:id: Soft delete user.

POST /admin/users/:id/lock: Lock account until datetime.

POST /admin/users/:id/unlock: Unlock account/reset attempts.

POST /admin/users/:id/resend-verify: Force verification email resend.

POST /admin/users/:id/reset-password: Trigger reset password email.

GET /admin/users/:id/sessions: View a user’s active sessions.

POST /admin/users/:id/signout-all: Revoke all sessions for a user.

Admin roles (RBAC)
GET /admin/roles: List roles.

POST /admin/roles: Create role with JSON permissions.

GET /admin/roles/:id: Get role details.

PUT /admin/roles/:id: Update role name/description/permissions.

DELETE /admin/roles/:id: Delete role (cascade as configured).

POST /admin/users/:id/roles: Assign role to user.

DELETE /admin/users/:id/roles/:roleId: Remove role from user.

GET /admin/users/:id/roles: List user’s roles (admin context).

Admin logs and maintenance
GET /admin/logs/login: Global login history (filters, ranges).

GET /admin/logs/security: Global security logs (filters).

GET /admin/stats: Dashboard metrics (users count, active sessions, signups).

GET /admin/maintenance/status: Maintenance status snapshot.

POST /admin/maintenance/cleanup: Invoke cleanup function/auth.cleanup_old_data.

POST /admin/sessions/revoke-all: Global logout (extreme measure).

Tokens (admin/debug)
GET /admin/tokens: List verification tokens (filters: user_id, type, used).

POST /admin/tokens/:id/revoke: Mark a token used/revoked.

POST /admin/tokens/issue: Manually issue a verification or magic-link token.

GET /admin/tokens/:id: Inspect a single token entry.

Consent and policies
GET /users/me/consents: List personal consents.

GET /admin/consents: Global consent logs (filters).

POST /admin/consents/revoke: Admin revoke a consent by user/version.

Views (reporting)
GET /views/active-users: Read-only view of active users.

GET /views/active-sessions: Read-only view of active sessions.

GET /views/recent-failed-logins: Read-only view of failed logins in 24h.

Platform admins (optional system administrator module)
GET /admin/system-users: List platform admins (auth.system_users).

POST /admin/system-users: Create a platform admin.

PATCH /admin/system-users/:id: Update platform admin fields.

POST /admin/system-users/:id/lock: Lock a platform admin account.

GET /admin/system-audit: List system audit logs (auth.system_audit_logs).

Total: 80 endpoints. You can trim or expand by combining token admin and platform admin features depending on scope.

OpenAPI tagging plan
Tags:

Auth

Users

Sessions

MFA

OAuth

Admin: Users

Admin: Roles

Admin: Logs

Admin: Maintenance

Tokens

Consents

Views

Admin: System (optional)

Conventions:

Use clear descriptions and examples for all request/response DTOs.

Document 2xx, 4xx, and 5xx responses consistently.

Include security schemas: bearerAuth (JWT access).

Reference shared components: ErrorResponse, PaginationMeta.

NestJS module plan
AuthModule: signup/signin/refresh/verify/resend/forgot/reset/magic-link; guards, strategies, rate limit.

UsersModule: me profile operations; DTOs and response mappers.

MfaModule: TOTP setup/enable/disable/verify; backup codes.

SessionsModule: list/revoke sessions; session service uses auth.sessions..

OauthModule: Google/GitHub flows; provider linking/unlinking; callbacks.

RolesModule: roles CRUD, user role assignment.

AdminModule: submodules for users, roles, logs, maintenance, sessions, system admins.

MailModule (global): Nodemailer + Handlebars; templates and resilient sending.

Database module: TypeORM or Prisma integration with schema auth; repositories/services.

DTO and validation patterns
General patterns:

create-user.dto.ts: email, password, full_name, date_of_birth, language, timezone; validate with class-validator.

signin.dto.ts: email, password, device context (device_id, device_type, device_name).

verify-email.dto.ts: code (6 digits, numeric string), or token depending on flow; tie to auth.verification_tokens.

forgot-password.dto.ts / reset-password.dto.ts: email for request; token + new_password for reset.

profile.dto.ts (patch): avatar_url, full_name, phone, language, timezone, metadata.

mfa-setup.dto.ts / mfa-enable.dto.ts / mfa-verify.dto.ts: secret, code, backup code arrays; password requirements for disable.

role.dto.ts: name, description, permissions (JSON).

admin filters DTOs: status, date range, search string, pagination params (page, limit).

session revoke DTOs: session_id (UUID).

Validation: Use class-validator (IsEmail, IsUUID, IsString, Length, Matches, IsIn, IsOptional, IsArray, IsBoolean, etc.). Transform query params with class-transformer.

Testing blueprint (Jest + Supertest)
E2E flows: auth.e2e-spec.ts

Signup: POST /auth/signup → assert 201

Read code/token from DB directly: simulate email retrieval

Verify email: POST /auth/verify-email → assert 200 and status active

Signin: POST /auth/signin → assert JWT and session created

Me: GET /users/me → assert profile data

Signout: POST /users/me/signout → assert session revoked

Integration tests per tag:

Auth: signup/signin/refresh/verify/resend/forgot/reset/magic-link

Users: me get/patch/password/email/delete/consent/security-logs/login-history

Sessions: list/revoke one/revoke all

MFA: setup/enable/disable/verify/backup codes

OAuth: provider flows + linking

Admin: users list/detail/create/edit/delete/lock/unlock; roles CRUD; logs list; maintenance cleanup

Coverage goals: 2xx and 4xx cases for each endpoint; include invalid payloads, unauthorized access, not found, rate limit exceed.

Postman collection hints
Variables: {{baseUrl}}, {{accessToken}}, {{refreshToken}}

Folders by tag: Auth, Users, Sessions, MFA, OAuth, Admin Users, Admin Roles, Admin Logs, Maintenance, Tokens, Consents, Views.

Examples: Provide request bodies and sample responses matching DTOs.

Chaining: Use test scripts to save tokens from responses to variables.

Implementation notes and SQL hooks
Signup flow:

Check uniqueness: email/username (auth.users).

Hash password: bcrypt.

Insert user: status pending_verification.

Generate 6-digit code: either store numeric code in auth.verification_tokens (token_type=email_verification) or store hex token and map to a code presented via email. Prefer single source: auth.create_verification_token(...).

Send email: with code and expiry.

Verify email:

Validate token/code: auth.validate_token('...', 'email_verification').

Set is_email_verified TRUE, status active; email_verified_at NOW(); write security log.

Signin:

Lookup password_hash and verify; check locked_until and status.

Create refresh token (UUID) + hash (SHA256); call auth.create_session(...).

Return access token (JWT) and raw refresh token (not stored raw), plus session info.

Refresh:

Find session by refresh_token_hash where is_active and expires_at > NOW().

Issue new access token; optionally rotate refresh (new UUID, update session).

Forgot/reset password:

Issue password_reset token via auth.create_verification_token; email link.

Validate token via auth.validate_token; update password_hash; write security log.**

Magic-link:

Issue magic_link token; mail link

Verify, then sign in without password; create session.

MFA:

Generate TOTP secret; present QR.

Enable after code verification; store mfa_secret and backup codes.

Disable requires password; blank secret and codes.

Sessions:

List active sessions; filter expires > NOW() and is_active TRUE.

Revoke by ID; set is_active FALSE and revoked_at NOW().

Revoke all for user; similarly.

OAuth:

Provider callbacks: create/link user; store tokens in auth.oauth_providers; create session; log oauth_linked; apply provider constraints.

Admin roles:

CRUD for roles; assign/remove roles via auth.user_roles, enforce UNIQUE (user_id, role_id).

Track changes in user_security_logs: role_assigned/role_removed events.

Logs/maintenance:

Login history filters: time range, status, IP, user.

Security logs filters: event_type, time range, user.

Cleanup: call auth.cleanup_old_data(); record into auth.maintenance_logs.

Views:

Use v_active_users, v_active_sessions, v_recent_failed_logins (create as needed).

Environment configuration (.env example)
Database: DATABASE_URL="postgresql://jcscode:123456@localhost:5432/jcscode?schema=auth"

Email: MAIL_HOST=smtp.hostinger.com; MAIL_PORT=465; MAIL_USER=no-reply@jcscode.com; MAIL_PASS="143300Ju="; MAIL_FROM="Equipe JCS Code <no-reply@jcscode.com>"

JWT: JWT_SECRET="super_complex_secret"; JWT_EXPIRATION="15m"; JWT_REFRESH_SECRET="another_complex_secret"; JWT_REFRESH_EXPIRATION="7d"

Rate limiting: THROTTLE_TTL=60; THROTTLE_LIMIT=5

TypeORM or Prisma mapping notes
TypeORM entities: Map to schema auth, reuse DB-generated UUIDs (PrimaryGeneratedColumn('uuid') is fine if you keep DB as source of truth; alternatively set @Column('uuid', { default: () => 'uuid_generate_v4()' })).

Prisma schema: Use native schema mapping to auth; disable migrations, introspect the DB; ensure uuid default is dbgenerated('uuid_generate_v4()').

Indices and constraints: Reflect partial indexes with query-level filters (Prisma limited support); enforce uniqueness constraints via DB.

Module scaffolding checklist
AuthController: signup/signin/refresh/verify/resend/forgot/reset/magic-link endpoints; apply ThrottlerGuard; log attempts with auth.login_history.

AuthService: core flows and DB hooks; mail sending; token issuance; password policies.

UsersController (me): secure via JWT guard; update profile; password change; email change; consents; delete; logs; sessions.

SessionsController: list/revoke; ensure only owner can revoke.

MfaController: setup/enable/disable/verify; backup codes endpoints.

OauthController: provider redirects/callbacks; linking; listing/unlinking.

Admin controllers: users (CRUD + lock/unlock + resend + reset), roles (CRUD + assign/remove), logs, maintenance, global sessions revoke.

MailModule: register in AppModule globally; use handlebars templates; wrap sendMail in try/catch; expose sendVerificationCode, sendResetPassword, sendSuspiciousLogin.

Swagger: decorate with @ApiTags per controller; add @ApiOperation and @ApiResponse with example DTOs; provide bearer auth scheme.

Example SQL snippets for common operations
Issue email verification token

Insert user, then call:

SELECT token, expires_at FROM auth.create_verification_token($user_id::uuid, 'email_verification', '24 hours'::interval, $ip::inet, $user_agent);

Validate email verification token

SELECT * FROM auth.validate_token($token, 'email_verification');

UPDATE auth.users SET is_email_verified = TRUE, email_verified_at = NOW(), status='active' WHERE id=$user_id AND deleted_at IS NULL;

Create session

SELECT auth.create_session($user_id, $refresh_token, $device_id, $device_type, $device_name, $ip::inet, $user_agent);

Cleanup

SELECT * FROM auth.cleanup_old_data();

Response shaping and error strategy
Success: Return standardized envelopes: { success: true, data: ..., message?: string, meta?: {...} }

Errors: { success: false, error: { code: '...', message: '...', details?: {...} } }, map 4xx vs 5xx appropriately.

Pagination: meta { page, limit, total }; support cursor pagination where helpful.